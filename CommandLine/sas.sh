#!/bin/bash
#===============================================================================
#
# This file is part of the SAS4A-SASSYS-1-Sandbox-Tools.
#
# See LICENSE for full details.
#
#===============================================================================

#===============================================================================
#
# Execute SAS4A/SASSYS-1 in the background for a given set of input files.
#
# A subdirectory of the directory containing each input file is created
# to contain all output files generated by SAS. The input file and the
# executable used to generate the output are also archived in this
# directory.
#
# The PATH environment variable is used to search for an appropriately-
# named executable. An available executable in the current working
# directory takes precedence over others available in the PATH. The
# recommended setup is to have this script and the corresponding
# executable in ~/bin and add ~/bin to PATH.
#
# A number of command-line options are available to modify the normal
# behavior. See 'Usage' for details.
#
# This script can easily be modifed to run post-processing utilities
# following successful execution of SAS.
#
#===============================================================================

VERSION="5.1"

ME=$(basename "$0")

Main ()
{
	# Make sure at least one argument has been provided:
	[ $# -gt 0 ] || { Usage; return 2; }

	Init || { return $?; }

	while [ $# -gt 0 ] ; do

		case "$1" in

		-h)
			Usage
			return
			;;

		-r)		# Choose restart file
			shift && [ $# -gt 0 ] || { Usage; return 2; }
			MY_RES="$1"
			;;

		+r)		# Clear choice of restart file
			MY_RES=
			;;

		-id)	# User-defined ID, rather than auto-generated
			shift && [ $# -gt 0 ] || { Usage; return 2; }
			MY_ID="$1"
			;;

		+id)	# Clear user-defined ID.
			MY_ID=
			;;

		-id=*)	# User-defined ID, rather than auto-generated
			MY_ID="${1#-id=}"
			;;

		-kill)	# We have a license to kill
			LICENSE="kill"
			;;

		+kill)	# Revoke the license
			LICENSE=
			;;

		-x)		# Select executable
			shift && [ $# -gt 0 ] || { Usage; return 2; }
			[ -x "$1" ] || { Error "$1 is not an executable."; return 1; }
			MY_EXE="$1"
			;;
		+x)		# Use default executable
			MY_EXE=
			;;

		-s)		# Strip output file
			STRIP="YES"
			;;

		-z)		# Extract ZIP archive
			shift && [ $# -gt 0 ] || { Usage; return 2; }
			MY_ZIP="$1"
			;;

		+z)		# Clear choice of zip archive file
			MY_ZIP=
			;;

		-*)		# Unrecognized option
			Error "Unrecognized option: $1"
			Usage
			return 2
			;;

		*)		# Anything else is assumed to be a file or directory

			if [ -n "$LICENSE" ] ; then
				KillSAS "$1"
			else
				Setup "$1" && { RunSAS & }
			fi
			;;

		esac

		shift	# shift to the next argument on the command line

	done
}

Usage ()
{
	cat <<-USAGE
	Usage: $ME [<options>...] <input>[.inp]...

	    OPTIONS:

	        -h          Help. Prints this message.

	        -id <name>  Use <name> to form the output directory rather than
	                    one generated automatically based on the date and time.
	                    The directory will be "<input>.<name>-<pid>".

	        -id=<name>  Same as -id above.

	        +id         Use an automatically generated name for the output
	                    directory. This cancels the effect of a prior -id[=].
	                    The directory will be "<input>.<date>-<time>-<pid>".
	                    This is the default.

	        -r <file>   Use <file> as a restart file. The specified file must
	                    already exist. It will be copied into the output
	                    directory with the name "RESTART.bin".

	        +r          Do not copy any files for restart.

	        -s          Strip resulting output files of unique run-time data.
	                    This is useful when comparing output files using 'diff'.

	        -kill       Terminate running jobs. Subsequent <input> arguments
	                    are interpreted as either an output directory, a
	                    direct reference to a PID file, or as the originating
	                    input from an existing run. If multiple jobs are
	                    identified, the user is presented with a choice
	                    of which job (or all jobs) to kill.

	        +kill       Do not terminate jobs. This cancels the effect of
	                    a prior -kill. Subsequent <input> arguments are
	                    interpreted as input files.

	        -x <sas>    Use <sas> as the executable for jobs run in the
	                    background. The default is to search for a release
	                    version of SAS in the user's search PATH.

	        +x          Use a release version of SAS from the user's search
	                    PATH. This cancels the effect of a previous -x. The
	                    release version is expected to be named "sas-<ostype>-
	                    <arch>-release.x".
	        -z <file>   Treat <file> as a 'zip' archive and extract its
	                    contents into the output directory prior to starting
	                    SAS. This is useful for coupled SAS/DIF3DK problems
	                    where cross-section libraries and other files need
	                    to be available during execution.

	USAGE
	return 0
}

Init ()
{
	Debug "Init..."

	# Clear options:
	MY_ID=
	LICENSE=
	STRIP=
	MY_EXE=
	MY_RES=
	MY_ZIP=

	# Set parameters:
	DEF_ID=$(date +%Y%m%d-%H%M%S)	# Default ID

	EXT="x"
	UNAM=$(uname -s)					# Try to indentify the OS type
	if [ "x${UNAM:0:6}" = "xCYGWIN" ] ; then
		UNAM="Cygwin"
		EXT="exe"
	fi
	SAS="sas-$VERSION-$UNAM.$EXT"
	MIN="mini-$VERSION-$UNAM.$EXT"

	local PATH=".:$PATH"			# See if we can find it, starting with CWD.
	DEF_EXE=$(which "$SAS") || DEF_EXE=$(which "$MIN") || { Debug "No default SAS executable is available."; }
	#Status "Using $DEF_EXE"
}

Setup ()
{
	Debug "Setup..."

	# Treat argument as an input file:
	JOB_INP="$1"
	[ -r "$JOB_INP" ] || { Error "Unable to read INPUT file: $JOB_INP"; return 1; }

	# Check for optional restart
	JOB_RES="$MY_RES"
	if [ -n "$JOB_RES" ]; then
		[ -r "$JOB_RES" ] || { Error "Unable to read RESTART file: $JOB_RES"; return 1; }
	fi

	# Check for optional zip archive
	JOB_ZIP="$MY_ZIP"
	if [ -n "$JOB_ZIP" ]; then
		[ -r "$JOB_ZIP" ] || { Error "Unable to read ZIP archive: $JOB_ZIP"; return 1; }
	fi

	# Check for available executable:
	JOB_EXE="${MY_EXE:-$DEF_EXE}"
	[ -x "${JOB_EXE}" ] || { Error "No SAS executable is available."; return 1; }

	INP_DIR=$(dirname "$JOB_INP")		# Extract input directory
	JOB_NAM=$(basename "$JOB_INP" .inp)	# Extract input base name
	JOB_ID="$JOB_NAM.${MY_ID:-$DEF_ID}-$$"
	JOB_DIR="$INP_DIR/$JOB_ID"			# Output directory
	JOB_OUT="$JOB_NAM.out"				# Generate output file name

	# Make sure output directory doesn't already exist:
	[ ! -d "$JOB_DIR" ] || { Error "Working directory already exists."; return 1; }

	# Create the output directory for all the files:
	mkdir "$JOB_DIR" || { Error "Unable to create working directory."; return 1; }

	Status "Running SAS: $JOB_ID"

	return 0
}

RunSAS ()
{
	Debug "RunSAS..."

	# Use '/bin/cp -p' to preserve file attributes (e.g. timestamps):
	/bin/cp -p "$JOB_INP"  "$JOB_DIR"	# Preserve input file
	[ -n "$JOB_RES" ] && /bin/cp -p "$JOB_RES" "$JOB_DIR/RESTART.bin"
	[ -n "$JOB_ZIP" ] && /usr/bin/unzip "$JOB_ZIP" -d "$JOB_DIR"

	/bin/cp -p "$JOB_EXE"  "$JOB_DIR"	# Preserve executable (why not)
	JOB_INP=$(basename "$JOB_INP")		# Use local copy
	JOB_EXE=$(basename "$JOB_EXE")		# Use local copy

	cd "$JOB_DIR"

	"./$JOB_EXE" < "$JOB_INP" > "$JOB_OUT"	# Run SAS and then rename output
											# files based on input file name
	JOB_STAT=$?

	if [ -n "$STRIP" ] ; then
		StripSAS "$JOB_OUT"				# Strip output files
	fi

	for data in fort.* *.dat ; do
		base=$(basename $data .dat)		# Avoid duplicate .dat extensions
		[ -r "$data" ] && mv "$data" "$JOB_NAM.$base.dat"
	done
	for log in *.log ; do
		mv "$log" "$JOB_NAM.$log"
	done

	Status "Done: $JOB_ID ($JOB_STAT)"
}

StripSAS ()
{
	local out="$1"
	local txt="`dirname $out`/`basename $out .out`.txt"

	sed -E \
		-e '/^(SAS4A\/SASSYS-1|CHANNEL)/s|[0-9]{8}  .{8}    (PAGE *[0-9]+)$|DATE: n/a TIME: n/a   PAGE: n/a|' \
		-e '/^JOB: /s|JOB: .{20} |JOB: n/a                  |' \
		-e '/^JOB: /s|USER: .*|USER: n/a|' \
		-e '/ADDRESS OF/s|= *[0-9]*$|= n/a|' \
		-e '/OFFSET/s|= *[0-9]* WORDS.$|= n/a|' \
		-e '/SAS4A\/SASSYS-1 TIMING INFORMATION/,/TOTAL/d' \
		-e '/^1.{121}PAGE.{4}$/s|(.{102}).{18}(.*)|\1DATE n/a  TIME n/a\2|' \
	"$out" > "$txt"
}

KillSAS ()
{
	Debug "KillSAS..."

	# If the argument is a directory, kill the process inside
	[ -d "$1" ] && { KillDir "$1"; return 0; }

	# Argument is a file. See if it is a PID file:
	[ -r "$1" -a $(basename "$1") = "SAS.pid" ] && { KillDir $(dirname "$1"); return 0; }

	# If we get here, assume it is an input file.
	INPT="$1"

	INP_DIR=$(dirname "$INPT")		# Extract input directory
	JOB_NAM=$(basename "$INPT" .inp)	# Extract input basename

	PIDS=$(ls "$INP_DIR/$JOB_NAM."*-[0-9]*/SAS.pid 2>/dev/null)
	[ -z "$PIDS" ] && { Status "No running jobs found for $INPT."; return 0; }

	select myPID in $PIDS "Kill All"; do
		if [ "$myPID" = "Kill All" ] ; then
			for myPID in $PIDS ; do
				KillDir $(dirname "$myPID")
			done
			break
		fi
		[ -n "$myPID" ] && { KillDir $(dirname "$myPID"); }
		break
	done

	return 0
}

KillDir()
{
	Status "Killing $1"

	PIDFILE="$1/SAS.pid"
	[ -r "$PIDFILE" ] || { Error "$PIDFILE does not exist."; return; }

	PID=$(grep PID "$PIDFILE" | awk '/PID/ {print $2;}')
	USER=$(grep USER "$PIDFILE" | awk '/USER/ {print $2;}')
	HOST=$(grep HOST "$PIDFILE" | awk '/HOST/ {print $2;}')

	[ $HOST = $(hostname) ] && { kill $PID && rm "$PIDFILE"; return; }

	# Process is on a remote host. Sniper mode...
	ssh ${USER:-$(id -un)}@$HOST kill $PID && rm "$PIDFILE"
}

Error ()
{
	echo "$ME: Error: $@"
	return 0
}

Debug ()
{
	#Status "$@"
	return 0
}

Status ()
{
	echo "$ME: $@"
	return 0
}

# Redirect all script output to stderr:
exec 1>&2

set -u

Main "$@"
